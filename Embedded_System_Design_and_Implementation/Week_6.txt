Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-04-03T13:40:04+10:00

====== Week 6 ======

===== Part 1 =====
has 16 bit and 32 bit timers
the bigger the timer, the longer the delay that can be created
32 bit can provide much higher resolution
	limits to how fast GPIO can be toggled
timers on **APB1** - 42 MHz and **APB2** - 84 MHz

==== sysTick timer ====
24 bit timer
requires priveliged mode
can trigger interrupt
can run off internal or external clock source
example for use - RTOS task switching - give each proccess 1ms of CPU time

=== SYST_CSR ===
* COUTFLAG - zero if timer has not gone off (counted to 0), 1 if it has - then sets itself back to 0
* CLKSOURCE - 0 for external clock, 1 for processor clock (default)
* TICINT - 0 if interrupt off, 1 if it should trigger interrupt
* ENABLE - 0 for off, 1 for on

=== SYS_RVR ===
reset value register
sets the count value of the timer
24 bits

=== SYS_CVR ===
the current value of the timer
32 bits wide (though basically only 24 because of RVR)

given that clock is 168 MHz, and timer divides it by 8 to give 21 MHz
For a 1ms timer, divide this by 1000 = 21 × 10^{3} = 0x5208
value could be dynamically computed using the calibration value - not present in all micros

===== Part 2 - Timer Peripherals =====
STM32F437xx - 39xx timers:
* 10 general purpose timers (TIM2-5, TIM9-14)
* 2 Advanced-Control (TIM1, TIM8)
* 2 Basic (TIM6, TIM7)

timers can be paused on the hardware
some timers have multiple timers, used to chain events or output waveforms
advanced timers are designed for 3 phase motor control
alternate functions on the timers can be used to control GPIO - enable before timer is started

==== Basic Timers ====
no GPIO output
RCC->APB1ENR to enable
RCC->APB1RSTR to reset

Prescaler - divides (slows) bus frequency (42MHz)

=== TIMx_CR1 - control register ===
APRE - auto reload, 1 to allow the timer to reload once it has reached the final count value
OPM - one pulse mode. 1 to stop the counter at the next update event
URS - update request source. 1 to only allow over / underflow to generate the interrupt
UDIS - 1 to disable event generation
CEN - enable bit
MMS - master mode selection. for timer chaining

=== TIMx_SR - status register ===
UIF - 1 if the counter has expired, can manually reset

=== TIMx_CNT - count register ===
count register, upper 16 bits should be masked to ensure valid data

=== TIMx_PSC - prescaler ===
{{./equation.png?type=equation}}
frequency = bus frequency / (prescale value + 1)

=== TIMx_ARR - auto-reload register ===
number of counts the timer will do
timer will not operate with 0 value
written back to counter after it expires
can be changed while timer is running, makes backup (shadow) copy



===== Lectorial =====
timer 6 code in lecture notes
simplest timer
(1 & 8) are advanced?
apb1 - 46 MHz
timers run at twice the rate?
gpio F already configured in template code - for external RAM clocks

bunch of constants in c header - use to enable certain bits
__asm("NOP"); — inline asm

GPIO_MODER_MODEx_Msk — 0x3 shifted into position (x)
use bit flip (~) of this to clear

to set
0x01 « GPIO_MODER_MODEx_Pos
or use 0x03 to set both bits, 0x02 to set 2nd bit
