Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-04-28T11:47:52+10:00

====== EEET2096 - Laboratory 2 ======
By Christopher Tait (S3899475)

===== Introduction =====
The aim of this lab is to develop an application that will allow an outside device to communicate and change the states of the LEDs on the circuit board. The development of this application will be done using Keil uVision to code in C and debug, as well as teraterm to to communicate over UART on a PC. Debugging on the hardware will be done with the help of a JLink device, which will allow code to be stepped line-by-line while it is deployed. This lab will use the in-built timers of the STM32F439 to flash the LEDs at a specific frequency. A serial interface of the microcontroller, using Universal Asynchronous Receive Transmit (UART), will allow input from an outside device.

===== Design and Implementation =====
The code was initially designed using the below flowchart, which was then translated into C code. The code was split up into functions for each of the setup steps, as well as utility functions for changing the LEDs.

{{.\flowchart.png}}
Flowchart of the operation of the lab code

==== LEDs ====
LEDs 0-7 were used in the lab, which means that GPIOA, B and F needed to be set up correctly in order for them to function. The "stm32f439xx.h" file made the process of setting up these LEDs much easier as the locations of the different setup registers did not need to be manually found in the STM32 reference manual. The setup_LEDs function sets up each LED individually, with its MODER, OTYPER, OSPEEDR, PUPDR and initial ODR values being set.
To turn the LEDs on an or was used on the ODR of GPIOA, B and F. Turning them off required an and with an inverse mask. To toggle LEDs an xor was used.

{{.\pasted_image002.png}}
{{.\pasted_image003.png}}
{{.\pasted_image004.png}}
Screenshot of GPIO A, B and F when they have been setup

==== Timers ====
The timer used in this lab was Timer 6, which is a basic 16-bit timer
**Prescale and Auto Reset Register (ARR) calculation:**
tick frequency = bus frequency (42 MHz) / (prescale value + 1)
	prescale value must be 16-bit unsigned value
final frequency = tick frequency / num. ticks (ARR)

For this lab, a prescale value of 15 and a ARR value of 5250 were used to produce a timer with 1000Hz frequency = 1ms

**Steps used to setup the timer:**
* enable the peripheral using APB1ENR and APB1RSTR registers
* disable the timer
* setup prescaler and ARR values
* enable and start the timer

{{.\pasted_image.png}}
Screenshot of timer when it has been setup on the simulator

In the code, a count variable is used to produce the right frequency from the 1ms timer. The target count value needed to be divided by two to make it run at the right speed because turning the LEDs on and off takes 2 counts. The one millisecond timer made it easy to implement and was easy to change to the right frequency. Once the correct count value had been reached, the LEDs were toggled. This value was changed via the state variable to index an array with the correct values. This was so that the state variable could be used to change the frequency and corresponding LED output.

==== UART ====
The STM32 microcontroller used in the lab has various different serial interfaces that can be used to communicate with different devices. This lab used the UART protocol to send data from a PC to the micro. UART3 was setup to have 8 data bits, 1 stop bit and no parity. GPIOB pin 10 and 11 also had to have their alternate function register changed in order for USART3 to work. The baud rate was 38,400, which needed to be converted into a form that could be set in the Baud Rate Register (BRR):

{{./equation.png?type=equation}}
(42*1e6) / (16*38_400)
68.359375
68 = 0x4
Then the fractional part was calculated as follows:
0.359375 * 16 = 5.75 = 0x6

{{.\pasted_image001.png}}
Screenshot of USART3 once it has been setup

Error checking was done by checking if the inputted character was in the range '0' to '9', otherwise it was discarded otherwise and the input buffer was cleared. After a valid character is inputted the input buffer of 3 characters, represented as uint8_t, is checked. If a valid sequence is detected, the state variable is changed, which will then change the output.

==== Deployment ====
The code worked after some errors were found:
* The count variable check used ==, would not work if state from higher to lower, and would skip over the required value
	* Solution: use >= instead
* USART input would only produce 0xFF in the input, and only when a newline was inputted in teraterm. This was very strange behaviour and help was needed to fix it.
	* This was due to an error in the initial baud rate calculation, which was off by a factor of 10.
* LEDs flashed at half the required frequency
	* Solution: divide count required to toggle the LEDs by 2
After these errors were fixed, the code was successfully demonstrated to the lab tutor.

===== Conclusion =====
In conclusion, the application was developed and tested successfully and demonstrated all required functionality. This included flashing the LEDs on the board at the right frequency, and changing this frequency when valid input was received over the UART interface. The most difficult aspect of development was the USRT setup as time was limited and a hard to debug error occurred because the baud rate was set wrong. To make the application more efficient and have a more accurate frequency, interrupts could be used with a non-stop timer to trigger the LED flashes.

===== References =====
[1] ST Microelectronics, “RM0090 – Reference Manual”, ST Microelectronics, June 2018, Available Online.
[2] ST Microelectronics, “PM0214 – Programming Manual”, ST Microelectronics, February 2019, Available Online.
