Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-03-24T11:37:20+11:00

====== Lab 2 ======
By Christopher Tait (S3899475)

===== Introduction =====
This lab will focus on configuring and using GPIO (General Purpose Input/Output) on the STM32 platform using ARM assembly code. The Keil uVision development environment will be used to simulate and debug this code. The culmination of the lab will be deploying the finished code onto the STM32F4II development board and debugging on the real hardware using a J-Link probe. The application will be developed with the help of the STM32 programming manual and the STM32 technical reference manual. There are 11 different GPIO ports available on the platform, all of which have 16 output pins except for GPIOK which has 8.
The development board's design dictates that the switches and LEDs on the board are active when the pin goes low. The GPIO will have to be successfully configured to have the switches on GPIOA pin 9 and 10 as inputs and the LEDs on GPIOB pin 8 and GPIOF pin 9 as outputs. The overall goal of the application is to have the L and R switches controll the states of the LEDs and seamlessly move between these states.

===== Design and Implementation =====
The design and implementation of the lab was split into four main parts which were:
* Enabling the GPIO clocks with the RCC module
* Setting up the GPIO
* Creating the main part of the application
* Hardware testing
The initial assembly template copied from pab 1 contained the reset, |.text|, Table and Result AREAs, of witch only the reset and |.text| were needed. The target settings were also the same, thought the Sim_ROM.ini file was added to the debug settings to simulate the GPIO.

==== Subroutine for RCC ====
Through reading the Technical reference manual, it was found that enabling GPIOA, GPIOB and GPIOF required the correct bits to be set in the RCC_AHB1ENR register. Then the RCC_AHB1RSTR register would have to be used to reset the same clocks, by setting the correct bits and then unsetting them. The layout of both of these registers was the same in terms of where the bits for the GPIO were, with bits 0-10 for GPIOA-K.
This means that bits 0, 1 and 5 were the important bits for GPIOA, B and F, so the mask that was used to enable the bits was 0b100011 = 0x23. The same mask could be used to disasble the bits with the BIC instruction.
With this information, a subroutine was created to first enable the correct bits in RCC_AHB1ENR, then enable them in RCC_AHB1RSTR, then a delay of two clock cycles was created using two NOP instructions. After this the bits in RCC_AHB1RSTR needed to be unset and another delay of two clock cycles to ensure the reset was successful.
During the development of this subroutine, a hard to track bug was found that caused the GPIO to not be enabled. The cause was a single ~ character before the mask used in the final BIC instruction. The ~ acted as a bit flip on the value during compilation, which caused only the non important bits to be unset.

==== Results of RCC code ====
{{.\pasted_image003.png}}
screenshot of AHB1ENR block (before initialization)

{{.\pasted_image004.png}}
screenshot of AHB1ENR block (after initialization)

{{.\pasted_image005.png}}
screenshot of AHB1RSTR (during initialization)


==== GPIO Registers ====
| Registers | Base Offset | GPIOA Value | GPIOB Value | GPIOF Value |
|:----------|:------------|:------------|:------------|:------------|
| MODER     | 0x00        | 0x0         | 0x10000     | 0x10000     |
| OTYPER    | 0x04        | 0x0         | 0x0         | 0x0         |
| OSPEEDR   | 0x08        | 0x0         | 0x0         | 0x0         |
| PUPDR     | 0x0C        | 0x140000    | 0x10000     | 0x10000     |
| IDR       | 0x10        | 0x0         |             |             |
| ODR       | 0x14        |             | 0x100       | 0x100       |
| BSRR      | 0x18        |             |             |             |

The values for GPIOB and F are the same, as LED 6 and 7 are both on pin 8 of B and F.

== Masks required: ==
Using the BIC instrction is easier than AND, so it will be used to clear specific bits

=== MODER ===
A 32 bit register for each GPIO, with 2 bits for each pin. Setting these two bits to 00 will put the pin into the input state, and setting them to 01 will put it into the output state.

**GPIOA**
value required:
	 v MODER 15                                                     v MODER 0
0b 00 00 00 00 00 **00** **00** 00 00 00 00 00 00 00 00 00
mask using BIC instruction
0b 00 00 00 00 00 11 11 00 00 00 00 00 00 00 00 00
= 0x140000

**GPIO B + F**
value required using ORR instruction to set bits:
0b 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00
= 0x10000
mask using BIC instruction
0b 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 00
= 0x20000

=== OTYPER ===
A 16 bit register for each GPIO. set to 0 for push-pull and 1 for open-drain. This lab will use push-pull for LEDs and switches

**GPIO A**
mask to unset bits 9 and 10 using BIC instruction
0b 0 0 0 0 0 **1** **1** 0 0 0 0 0 0 0 0 0
= 0x600

**GPIO B+F**
mask to unset bit 8 using BIC
0b 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
= 0x100

=== OSPEEDR ===
Two bits for each pin, 00 to 11 for low to very high speed. Since the LEDs and switched are used for human interaction, low speed is sufficient
**GPIOA**
same as MODER for GPIOA

**GPIO B + F**
value required:
0b 00 00 00 00 00 00 00 **00** 00 00 00 00 00 00 00 00
mask that will be used in BIC:
0b 00 00 00 00 00 00 00 **11** 00 00 00 00 00 00 00 00
= 0x30000

=== PUPDR ===
Used to controll pull-up and pull-down resistors. 00 used for nothing, 01 for pull-up and 10 for pull-down. Pull down resistors are used on the switches and LEDs to prevent a floating state where the input/output could be influenced by any electromagnetic interference.

**GPIOA**
set pull-up on all used ports
bits set using ORR
0b 00 00 00 00 00 **01** **01** 00 00 00 00 00 00 00 00 00
= 0x140000
bits unset using BIC
0b 00 00 00 00 00 **10** **10** 00 00 00 00 00 00 00 00 00
= 0xA0000

**GPIO B + F**
bits set using ORR
0b 00 00 00 00 00 00 00 **01** 00 00 00 00 00 00 00 00
= 0x10000
bits unset using BIC
0b 00 00 00 00 00 00 00 **10** 00 00 00 00 00 00 00 00
= 0x20000

==== Results of GPIO setup ====
{{.\pasted_image006.png}}
GPIOA after configuration

{{.\pasted_image007.png}}
GPIOB after configuration

{{.\pasted_image008.png}}
GPIOF after configuration

As seen in the above figures, the GPIOs have been setup correctly for GPIOA to be used for the switches and GPIOB and F to be used for the LEDs

==== Design of application ====
The design of my app in centred around a main loop which has the 50ms delay and reading of the input state at the beginning. It then branches into one of four different states based on the value of the switches. Within each state, another subroutine is used to set the LEDs and delay for the right ammount for the flashing. The BL instruction is used to branch into these subroutines and the BX instruction is used to branch back to where they are called. Each state then branches back to the start of the loop with a regular branch because the BL instruction will overwrite the link register so it can only be used for one level by default.

This design was based of the figure 3 flowchart in the lab specification and follows it pretty closely. Some issues with this design is that the switches are not debounced and the application can take some time to change states, because the delay is done on the CPU.

==== Simulation ====
To simulate the switches, the value of GPIOA_IDR must be manually set in the assembler simulation

State 1 - No switches pressed
{{.\pasted_image010.png}}
Since the switches are active low, both pins would be high when neither is pressed

{{.\pasted_image011.png}}
The code correctly branches into state1

State 2 - Left switch pressed (GPIOA_IDR9 high and GPIOA_IDR10 low)
{{.\pasted_image012.png}}

State 3 - Right switch pressed (GPIOA_IDR9 low and GPIOA_IDR10 high)
{{.\pasted_image013.png}}

State 4 - Both switches pressed (GPIOA_IDR9 low and GPIOA_IDR10 low)
{{.\pasted_image009.png}}

==== Deployment ====
Once the simulation was verified to be working correctly, the code was tested on the development platform with the J-Link.

State 1
{{.\IMG_20230405_154956.jpg?width=600}}
{{.\IMG_20230405_154957.jpg?width=600}}

State 2
{{.\IMG_20230405_155013.jpg?width=600}}
{{.\IMG_20230405_155015.jpg?width=600}}

State 3
{{.\IMG_20230405_155020.jpg?width=600}}

State 4
{{.\IMG_20230405_155417.jpg?width=600}}


===== Conclusion =====
In conclusion, the application was a success and the GPIO for all inputs and output were configured successfully. The simulated and real results were the same, so the app is verified to be working correctly. The current code currently uses a software timer, but a hardware timer could be used for more accurcy and to free up the CPU. This would require a more complex design aswell.

===== References =====
[1] ST Microelectronics, “RM0090 – Reference Manual”, ST Microelectronics, June 2018, Available Online.
[2] ST Microelectronics, “PM0214 – Programming Manual”, ST Microelectronics, February 2019, Available Online.
