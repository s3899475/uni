Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-03-10T12:24:32+11:00

====== Laboratory 1 - Introduction to ARM Assembler ======
By Christopher Tait (S3899475)

===== Introduction =====
This lab will serve as an introduction on how to write and debug ARM assembler code for the STM32F439II using Keil uVision. Supporting documents, such as the ARM Cortex M4+ assembler manual and the STM32 programming manual will be needed in order to investigate the operation of some different assembler instructions. These instructions will include arithmetic and memory access operations, as well as control flow (branch) operations. The Keil uVision development environment will be used to gain an understanding of how each individual instruction affects the state of the microcontroller, such as the values of its registers and memory.

===== Design and Implementation =====
==== Section 1 ====
=== Before Execution ===
{{.\pasted_image004.png}}
The values of R1-R3 before Section 1 is executed

{{.\pasted_image005.png}}
The memory pointed to by R1-R3

=== After Execution ===
{{.\pasted_image.png}}
The values of R1-R3 after Section 1 is executed

{{.\pasted_image001.png}}
The memory pointed to by R1

{{.\pasted_image002.png}}
The memory pointed to by R2

{{.\pasted_image003.png}}
The memory pointed to by R3

==== Section 2 ====
{{.\pasted_image006.png}}
The value of R0-R3

{{.\pasted_image007.png}}
The four bytes pointed to by R2

{{.\pasted_image008.png}}
The four bytes pointed to by R3

The STR instruction was used to store the value of R0 at the memory pointd to by R2 and the STRB instruction was used for R3. The behavior is as expected as only one byte was written for the STRB instruction

==== Section 3 ====
{{.\pasted_image009.png}}
The register file just after Section 3 was executed.

In this section, the LDR instruction was used to load data into R4 and the LDRB instruction was used to load R5. The difference between the two is that LDR by default loads a word (32 bits) and LDRB only loads a byte (8 bits)

==== Section 4 ====
| Assembly Instruction | Address    | Machine Code (Opcode) | Explanation                                                  |
|:---------------------|:-----------|:----------------------|:-------------------------------------------------------------|
| LDR R1, =tblConstant | 0x0800001C | 0x4916                | load from PC-relative label 'tblConstant' into R1            |
| LDR R2, =tblSpace1   | 0x0800001E | 0x4A18                | load from PC-relative label 'tblSpace' into R2               |
| MOV R0, #0x08        | 0x08000020 | 0xF04F0008            | Move the value 0x08 into R0                                  |
| loop1 LDRB R3, [R1]  | 0x08000024 | 0x780B                | Load a byte of memory, pointed to by R1, into R3             |
| STRB R3, [R2]        | 0x08000026 | 0x7013                | Store a byte of R3 into the memory location pointed to by R2 |
| ADD R1, R1, #0x01    | 0x08000028 | 0xF1010101            | Add 1 to R1, store the result in R1                          |
| ADD R2, R2, #0x01    | 0x0800002C | 0xF1020201            | Add 1 to R2, store the result in R2                          |
| SUBS R0, R0, #0x01   | 0x08000030 | 0x1E40                | Subtract 1 from R0 and set the status register               |
| BNE loop1            | 0x08000032 | 0xD1F7                | Branch back to loop1 if negative flag set in status register |


=== Before Execution ===
{{.\pasted_image010.png}}
Contents of tblSpace0

{{.\pasted_image011.png}}
Contents of tblSpace1

=== After Executon ===
{{.\pasted_image012.png}}
Contents of tblSpace0

{{.\pasted_image013.png}}
Contents of tblSpace1

This section includes the same functionality as a for loop in most programming languages, as it sets a variable to 8 and decrements it at then end of each loop. Once the variable is below zero, the for loop ends. The code steps through each byte of the 'tblConstant' array and copies it into 'tblSpace1'. To do this, it stores a pointer to each array in R1 and R2, and then increments the pointer at each loop so that the next value can be read and written.

==== Section 5 ====
| Assembly Instruction | Address    | Machine Code (Opcode) | Explanation                                                  |
|:---------------------|:-----------|:----------------------|:-------------------------------------------------------------|
| LDR R1, =tblConstant | 0x08000034 | 0x4910                | Load value from PC-Relative label tblConstant into R1        |
| LDR R3, =tblSpace0   | 0x08000036 | 0x4B11                | Load value from PC-Relative label tblSpace0 into R3          |
| MOV R0, #0x07        | 0x08000038 | 0xF04F0007            | Move the value 0x07 into R0                                  |
| MOV R2, #0x00        | 0x0800003C | 0xF04F0200            | Move the value 0 into R2                                     |
| LDRB R2, [R1]        | 0x08000040 | 0x780A                | Load a byte of memory, pointed to by R1 in to R2             |
| ADD R1, R1, #0x01    | 0x08000042 | 0xF1010101            | Add 1 to R1, store the result in R1                          |
| loop2 LDRB R4, [R1]  | 0x08000046 | 0x780C                | Load a byte of memory, pointed to by R1 in to R4             |
| SUB R2, R2, R4       | 0x08000048 | 0xEBA20204            | Subtract R4 from R2, store the result in R2                  |
| ADD R1, R1, #0x01    | 0x0800004C | 0xF1010101            | Add 1 to R1                                                  |
| SUBS R0, R0, #0x01   | 0x08000050 | 0x1E40                | Subtract 1 from R0, set the status register                  |
| BNE loop2            | 0x08000052 | 0xD1F8                | Branch back to loop2 if negative flag set in status register |
| STR R2, [R3]         | 0x08000054 | 0x601A                | Store the value of R2 at the memory pointed to by R3         |

{{.\pasted_image014.png}}
The value of R2 before section 5 is run

at the start of this section, R2 is reset to 0 so that the subtraction result can be stored in it

{{.\pasted_image015.png}}
The value of R2 after execution

{{.\pasted_image016.png}}
The array subtraction result

The final instruction could be changed to "STRB R2, [R3]" if we did not care about the other bits in R2, which are modified when it underflows.

==== Section 6 ====
Assembler code:
	''LDR R1, =tblConstant2''
	''LDR R2, =tblSpace0''
	''LDR R6, [R1], #0x04''
	''LDR R7, [R1], #0x04''
	''LDR R8, [R1], #0x04''
	''LDR R9, [R1]''
	''MUL R6, R6, R7''
	''MLA R6, R6, R8, R9''
	''STR R6, [R2]''

Pseudocode:
	''let R1 = pointer to tblConstant2[0]''
	''let R2 = pointer to tblSpace0[0]''
	''let R6 = 32-bit value at R1''
	''R1 = R1 + 4 bytes''
	''let R7 = 32-bit value at R1''
	''R1 = R1 + 4 bytes''
	''let R8 = 32-bit value at R1''
	''R1 = R1 + 4 bytes''
	''let R9 = 32-bit value at R1''
	''R6 = R6 * R7''
	''R6 = R6 * R8 + R9''
	''store R6 at memory at R2''

The MUL instruction multiplies the values from Rn and Rm, and places the least significant 32 bits of the result in Rd.

MLA{cond} Rd, Rn, Rm, Ra ; Multiply with accumulate
The MLA instruction multiplies the values from Rn and Rm, adds the value from Ra, and places the least significant 32 bits of the result in Rd

LDR without B, means load a Word

the result should be 0x285D E2D3 2140 8ABA
actual result = 0x2140 8ABA because the upper 32 bits are cut off

167 - start cycle
184 - end cycle
17 cycles were used

0.00001392s - start time
0.00001533s - end time
0.00000141s - total time

===== Discussion =====
a. Description of pseudo instructions:
	1. EQU - Used to define constant values with a specific name
	2. DCB - Used to manually allocate one or more bytes of memory in the current area
	3. DCD - Used to manually allocate one or more words in the current area. Will make sure that they are aligned (use DCDU to ignore alignment)
b. With the 'LDR R3, =tblSpace0' instruction, the MCU loaded a value at a location relative to the current PC (Program Counter), that could be up to Â± 4095 bytes away. This value was a 32-bit address that would then be loaded into the desination register (R3).
c. Microcontroller status flags - most conditional branch instructions check if a flag is set or unset (1 or 0)
	1. N - Negative Flag: set to 1 if operation result was less than zero
	2. Z - Zero Flag: set to 1 if the operation result was zero
	3. C - Carry/Borrow Flag: set to 1 if addition resulted in a carry, or subtract did not result in a borrow bit
	4. V - Overflow flag: set to 1 if the operation result overflowed
	5. Q - DSP Overflow and Saturation flag: set to 1 if the SSAT or USAT instruction results in saturation or indicates a DSP overflow. Must be manually reset using MRS instruction
d. Examples of branch instructions:
	1. BEQ - branch if values are equal
	2. BNE - branch if values not equal
	3. BMI - branch if result is negative
	4. BVS - branch if reult overflowed
	5. BGE - branch if 1st value greater or equal to 2nd value (signed)
	6. BAL - always branch
e. Code included in uVision file, but I will include it here as well
''; new Section 5''
	''LDR R1, =tblConstant''
	''LDR R3, =tblSpace1''
	''MOV R0, #0x03''
	''MOV R2, #0x00''
	''LDRH R2, [R1]''
	''ADD R1, R1, #0x2''

''loop2''
	''LDRH R4, [R1]''
	''SUB R2, R2, R4''
	''ADD R1, R1, #0x2''
	''SUBS R0, R0, #0x1''
	''BNE loop2''
	''STR R2, [R3]''

===== Conclusion =====
In conclusion, the operation of the lab 1 ARM assembler code was investigated. The code included arithmetic, branch and memory access instructions, all of which were needed for the functions of the program. The branch instructions were used to move between different labels in the code conditionally, so that simple loops could be formed. The programming manual was of great help when learning how each instruction worked, as well as how to modify them through conditionals such as EQ, NE, MI, etc. The memory view feature of Keil uVision was a great help to understanding the layout of the MCU's memory, as well as how the different memory access instructions worked
