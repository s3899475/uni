Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-06-12T16:26:30+10:00

====== Revision ======

===== Brute force =====
enumerate all solutions and select the best one
e.g.
* Searching an unordered list
* Computing a^n (multily multiple times)

==== Selection Sort ====
scan array to find smallest value
swap it with the first
keep going until the array is sorted

=== Complexity: ===
O(n^2)

=== Advantages: ===
only makes O(n) writes. useful when writes are much more expensive than reads

==== Bubble sort ====
compare adjacent items and swap them if they are not in order

=== Complexity ===
Best, worst and average: O(n^2)
can use early termination to terminate when the array is sorted

===== Decreace and Conquer =====
reduce a problem to a smaller instance of the same problem
solve the smaller instance
extend the smaller instance to obtain the solution to the original problem

=== Decrease-by-a-constant ===
* Insertion Sorting
* Topological Sorting
* Algorithms for generating permutations and subsets
=== Decrease-by-a-constant-factor ===
* Binary Search
* Fake-coin Problem
* Multiplication à la russe
* Josephus Problem
=== Variable-size-decrease ===
* Search, Insert and Delete in a Binary Search Tree
* Euclid’s Algorithm
* Interpolation Search
* Selection by Partitioning
* Game of Nim

==== Insertion Sort ====
go through items in an array one at a time
insert each element into the sorted array at the propper place

=== Complexity ===
Worst, average: O(n^2)

===== Divide and Conquer =====
Divide problem into smaller subproblems
Solve each subproblem (recursively)
combine smaller solutions to solve the original instance

==== Merge Sort ====
divide array into sub arrays for each element
merge the arrays so that each is sorted
stable sorting algorithm

=== Time Complexity: ===
always O(n*log(n))

==== Quick Sort ====
select a pivot element from the array that, we hope, about half the elements will come before and half after in a sorted array.
Partition the array so that all elements with a value less than the pivot are in one subarray, and larger elements in the other subarray.
Swap pivot into position of the array so that it is between the two subarrays
recursively apply the same procedure on the two subarrays.
Terminate when subarrays are of one element.

=== Time Complextity ===
Best case: O(n*log2(n))
Worst case: O(n^2)
Average case: O(b*log(n))

===== Transform and Conquer =====
