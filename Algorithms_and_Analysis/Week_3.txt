Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-03-12T22:09:10+11:00

====== Week 3 ======
Contents:
[*] [[#Part 1: Analyzing Recursive Algorithms|Part 1: Analyzing Recursive Algorithms]]
[*] [[#Part 2: Empirical Analysis|Part 2: Empirical Analysis]]
[*] [[#Part 3: Rule of Thumb Estimation of Complexity|Part 3: Rule of Thumb Estimation of Complexity]]

===== Part 1: Analyzing Recursive Algorithms =====
=== e.g. Factorial pseudocode ===
''if n = 1 then''
	''return 1''
''else''
	''return F(n - 1) * n''
''end if''

n = 1 is the base case/termination condition

==== steps to analyze: ====
* determine input size
* identify the basic operation
* setup a recurrence relation for C(n), including termination condition(s)
* simplify using **backward substitution** (Appendix B)
* determine equivalence class g(n) that bounds t(n) = c_op C(n)
	* c_op is not important
	* we generally want the tightest bound possible (Θ(n))

=== recurrence relation ===
represents a sequence of terms
Must include the termination condition

For example, for factorial of n
{{./equation002.png?type=equation}}
the recurrence relation is: **???? not recurrence relation - C(n) thing is**
{{./equation001.png?type=equation}}

=== e.g. from factorial pseudocode ===
basic operation: multiplication
Input size: n (function calls itself n times)
Recurrence relation and conditions: The number of multiplications
{{./equation003.png?type=equation}}
C(1) = 0 because there are no multiplications when n = 1

=== Backwards substitution e.g. 1 ===
Aim: Convert to normal C(n) form
{{./equation004.png?type=equation}}
solution:
{{./equation009.png?type=equation}}
C(n) cannot be negative, so i ≤ n??? - different in next qs

=== Backwards substitution e.g. 2 ===
Recurrence relation:
{{./equation006.png?type=equation}}
solution:
{{./equation007.png?type=equation}}

===== Part 2: Empirical Analysis =====
A different type of analysis - measurement
|                                 <| Pros                                         <| Cons                                                <|
|:---------------------------------|:----------------------------------------------|:-----------------------------------------------------|
| Formal Analysis (theoretical)    | No interference from implementation/hardware  | Hides constant factors. Requires a different mindset |
| Empirical Analysis (measurement) | Discovers the true impace of constant factors | May be running on the "wrong" inputs                 |

When designing an experiment:
* Understand the experiment's purpose
* Decide on the efficiency metric M to be measured and the measurement unit (an operation's count vs. a time unit)
* Decide on the characteristics of the input sample (range, size, number types (int, float, etc.))
* write a program for the experiment
* get a sample of inputs - use standard benchmarks of generate it yourself

===== Part 3: Rule of Thumb Estimation of Complexity =====
=== O(1) ===
typically algorithms or data structures whose operation does not depend on input size
e.g. array access (pointer access)
=== O(n) ===
operations need to evaluate most or all of the elements of a problem
e.g. linear search through an array, array copy
in pseudocode, usually involves a single loop
=== O(n^{2}) ===
typically needs to process/evaluate pairs of elements in a problem
e.g. compare each element in an array to all others, compute all pairwise distances
pseudocode usually involves two nested for loops
